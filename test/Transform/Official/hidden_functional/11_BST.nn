global ptr now init with i32 0
global ptr left_child init with 10000 x i32 zeros
global ptr value init with 10000 x i32 zeros
global ptr right_child init with 10000 x i32 zeros
global ptr LF init with i32 10
global ptr maxNode init with i32 10000
global ptr space init with i32 32
i32 insert(i32 root, i32 x) {
entry84:
  88 = sub i32 0, i32 1
  89 = icmp eq i32 %root, i32 %88
  br i1 %89, bb %then90, bb %else92
then90:
  94 = call i32 new_node(i32 %x)
  ret i32 %94
if.exit91:
  ret i32 %root
else92:
  97 = mul i32 %root, i32 4
  98 = ptradd ptr @value, i32 %97
  98.load = load i32 from ptr %98
  100 = icmp sgt i32 %x, i32 %98.load
  br i1 %100, bb %then101, bb %else103
then101:
  105 = mul i32 %root, i32 4
  106 = ptradd ptr @right_child, i32 %105
  108 = mul i32 %root, i32 4
  109 = ptradd ptr @right_child, i32 %108
  109.load = load i32 from ptr %109
  112 = call i32 insert(i32 %109.load, i32 %x)
  store i32 %112 to ptr %106
  br bb %if.exit102
if.exit102:
  br bb %if.exit91
else103:
  114 = mul i32 %root, i32 4
  115 = ptradd ptr @left_child, i32 %114
  117 = mul i32 %root, i32 4
  118 = ptradd ptr @left_child, i32 %117
  118.load = load i32 from ptr %118
  121 = call i32 insert(i32 %118.load, i32 %x)
  store i32 %121 to ptr %115
  br bb %if.exit102
}

i32 new_node(i32 x) {
entry66:
  now.load = load i32 from ptr @now
  69 = mul i32 %now.load, i32 4
  70 = ptradd ptr @value, i32 %69
  store i32 %x to ptr %70
  now.load72 = load i32 from ptr @now
  73 = mul i32 %now.load72, i32 4
  74 = ptradd ptr @left_child, i32 %73
  75 = sub i32 0, i32 1
  store i32 %75 to ptr %74
  now.load76 = load i32 from ptr @now
  77 = mul i32 %now.load76, i32 4
  78 = ptradd ptr @right_child, i32 %77
  79 = sub i32 0, i32 1
  store i32 %79 to ptr %78
  now.load80 = load i32 from ptr @now
  81 = add i32 %now.load80, i32 1
  store i32 %81 to ptr @now
  83 = sub i32 %81, i32 1
  ret i32 %83
}

i32 delete(i32 root, i32 x) {
entry123:
  127 = sub i32 0, i32 1
  128 = icmp eq i32 %root, i32 %127
  br i1 %128, bb %then129, bb %if.exit130
then129:
  131 = sub i32 0, i32 1
  ret i32 %131
if.exit130:
  134 = mul i32 %root, i32 4
  135 = ptradd ptr @value, i32 %134
  135.load = load i32 from ptr %135
  137 = icmp sgt i32 %x, i32 %135.load
  br i1 %137, bb %then138, bb %else140
then138:
  142 = mul i32 %root, i32 4
  143 = ptradd ptr @right_child, i32 %142
  145 = mul i32 %root, i32 4
  146 = ptradd ptr @right_child, i32 %145
  146.load = load i32 from ptr %146
  149 = call i32 delete(i32 %146.load, i32 %x)
  store i32 %149 to ptr %143
  br bb %if.exit139
if.exit139:
  ret i32 %root
else140:
  152 = mul i32 %root, i32 4
  153 = ptradd ptr @value, i32 %152
  153.load = load i32 from ptr %153
  155 = icmp slt i32 %x, i32 %153.load
  br i1 %155, bb %then156, bb %else158
then156:
  160 = mul i32 %root, i32 4
  161 = ptradd ptr @left_child, i32 %160
  163 = mul i32 %root, i32 4
  164 = ptradd ptr @left_child, i32 %163
  164.load = load i32 from ptr %164
  167 = call i32 delete(i32 %164.load, i32 %x)
  store i32 %167 to ptr %161
  br bb %if.exit157
if.exit157:
  tmp.phi333 = phi [bb %if.exit186, i32 %tmp.phi, bb %then156, i32 ub]
  br bb %if.exit139
else158:
  169 = mul i32 %root, i32 4
  170 = ptradd ptr @left_child, i32 %169
  170.load = load i32 from ptr %170
  172 = sub i32 0, i32 1
  173 = icmp eq i32 %170.load, i32 %172
  br i1 %173, bb %select.then174, bb %select.else175
select.then174:
  179 = mul i32 %root, i32 4
  180 = ptradd ptr @right_child, i32 %179
  180.load = load i32 from ptr %180
  182 = sub i32 0, i32 1
  183 = icmp eq i32 %180.load, i32 %182
  br bb %select.exit176
select.else175:
  br bb %select.exit176
select.exit176:
  select177.phi = phi [bb %select.else175, i1 0, bb %select.then174, i1 %183]
  br i1 %select177.phi, bb %then185, bb %else187
then185:
  188 = sub i32 0, i32 1
  ret i32 %188
if.exit186:
  br bb %if.exit157
else187:
  190 = mul i32 %root, i32 4
  191 = ptradd ptr @left_child, i32 %190
  191.load = load i32 from ptr %191
  193 = sub i32 0, i32 1
  194 = icmp eq i32 %191.load, i32 %193
  br i1 %194, bb %select.then195, bb %select.else196
select.then195:
  br bb %select.exit197
select.else196:
  200 = mul i32 %root, i32 4
  201 = ptradd ptr @right_child, i32 %200
  201.load = load i32 from ptr %201
  203 = sub i32 0, i32 1
  204 = icmp eq i32 %201.load, i32 %203
  205 = icmp ne i1 %204, i1 0
  br bb %select.exit197
select.exit197:
  select198.phi = phi [bb %select.else196, i1 %205, bb %select.then195, i1 1]
  br i1 %select198.phi, bb %then207, bb %else209
then207:
  211 = mul i32 %root, i32 4
  212 = ptradd ptr @left_child, i32 %211
  212.load = load i32 from ptr %212
  214 = sub i32 0, i32 1
  215 = icmp eq i32 %212.load, i32 %214
  br i1 %215, bb %then216, bb %else218
if.exit208:
  tmp.phi = phi [bb %else209, i32 %232]
  br bb %if.exit186
else209:
  229 = mul i32 %root, i32 4
  230 = ptradd ptr @right_child, i32 %229
  230.load = load i32 from ptr %230
  232 = call i32 find_minimum(i32 %230.load)
  234 = mul i32 %root, i32 4
  235 = ptradd ptr @value, i32 %234
  237 = mul i32 %232, i32 4
  238 = ptradd ptr @value, i32 %237
  238.load = load i32 from ptr %238
  store i32 %238.load to ptr %235
  241 = mul i32 %root, i32 4
  242 = ptradd ptr @right_child, i32 %241
  244 = mul i32 %root, i32 4
  245 = ptradd ptr @right_child, i32 %244
  245.load = load i32 from ptr %245
  248 = mul i32 %232, i32 4
  249 = ptradd ptr @value, i32 %248
  249.load = load i32 from ptr %249
  251 = call i32 delete(i32 %245.load, i32 %249.load)
  store i32 %251 to ptr %242
  br bb %if.exit208
then216:
  220 = mul i32 %root, i32 4
  221 = ptradd ptr @right_child, i32 %220
  221.load = load i32 from ptr %221
  ret i32 %221.load
if.exit217:
  br bb %if.exit208
else218:
  224 = mul i32 %root, i32 4
  225 = ptradd ptr @left_child, i32 %224
  225.load = load i32 from ptr %225
  ret i32 %225.load
}

i32 find_minimum(i32 root) {
entry43:
  46 = sub i32 0, i32 1
  47 = icmp eq i32 %root, i32 %46
  br i1 %47, bb %then48, bb %else50
then48:
  51 = sub i32 0, i32 1
  ret i32 %51
if.exit49:
  ret i32 %root
else50:
  53 = mul i32 %root, i32 4
  54 = ptradd ptr @left_child, i32 %53
  54.load = load i32 from ptr %54
  56 = sub i32 0, i32 1
  57 = icmp ne i32 %54.load, i32 %56
  br i1 %57, bb %then58, bb %if.exit59
then58:
  61 = mul i32 %root, i32 4
  62 = ptradd ptr @left_child, i32 %61
  62.load = load i32 from ptr %62
  64 = call i32 find_minimum(i32 %62.load)
  ret i32 %64
if.exit59:
  br bb %if.exit49
}

external i32 getint()

external i32 getch()

i32 search(i32 root, i32 x) {
entry:
  4 = sub i32 0, i32 1
  5 = icmp eq i32 %root, i32 %4
  br i1 %5, bb %select.then, bb %select.else
select.then:
  br bb %select.exit
select.else:
  11 = mul i32 %root, i32 4
  12 = ptradd ptr @value, i32 %11
  12.load = load i32 from ptr %12
  15 = icmp eq i32 %12.load, i32 %x
  16 = icmp ne i1 %15, i1 0
  br bb %select.exit
select.exit:
  select.phi = phi [bb %select.else, i1 %16, bb %select.then, i1 1]
  br i1 %select.phi, bb %then, bb %else
then:
  ret i32 %root
if.exit:
  unreachable
else:
  24 = mul i32 %root, i32 4
  25 = ptradd ptr @value, i32 %24
  25.load = load i32 from ptr %25
  27 = icmp sgt i32 %x, i32 %25.load
  br i1 %27, bb %then28, bb %else30
then28:
  32 = mul i32 %root, i32 4
  33 = ptradd ptr @right_child, i32 %32
  33.load = load i32 from ptr %33
  36 = call i32 search(i32 %33.load, i32 %x)
  ret i32 %36
if.exit29:
  br bb %if.exit
else30:
  38 = mul i32 %root, i32 4
  39 = ptradd ptr @left_child, i32 %38
  39.load = load i32 from ptr %39
  42 = call i32 search(i32 %39.load, i32 %x)
  ret i32 %42
}

external void putint(i32 )

external i32 getarray(ptr )

external i32 getfarray(ptr )

i32 main() {
entry277:
  store i32 0 to ptr @now
  279 = call i32 getint()
  281 = icmp ne i32 %279, i32 0
  282 =  i1 %281, i1 1
  283 = zext i1 %282 to i32
  284 = icmp ne i32 %283, i32 0
  br i1 %284, bb %then285, bb %if.exit286
then285:
  ret i32 0
if.exit286:
  288 = call i32 getint()
  289 = call i32 new_node(i32 %288)
  br bb %while.cond
while.cond:
  i.phi338 = phi [bb %if.exit286, i32 1, bb %while.body, i32 %302]
  296 = icmp slt i32 %i.phi338, i32 %279
  297 = icmp ne i1 %296, i1 0
  br i1 %297, bb %while.body, bb %while.exit
while.body:
  299 = call i32 getint()
  300 = call i32 insert(i32 %289, i32 %299)
  302 = add i32 %i.phi338, i32 1
  br bb %while.cond
while.exit:
  call void inorder(i32 %289)
  LF.load = load i32 from ptr @LF
  call void putch(i32 %LF.load)
  307 = call i32 getint()
  br bb %while.cond308
while.cond308:
  i.phi = phi [bb %while.exit, i32 0, bb %while.body309, i32 %319]
  root.phi = phi [bb %while.exit, i32 %289, bb %while.body309, i32 %317]
  313 = icmp slt i32 %i.phi, i32 %307
  314 = icmp ne i1 %313, i1 0
  br i1 %314, bb %while.body309, bb %while.exit310
while.body309:
  316 = call i32 getint()
  317 = call i32 delete(i32 %root.phi, i32 %316)
  319 = add i32 %i.phi, i32 1
  br bb %while.cond308
while.exit310:
  call void inorder(i32 %root.phi)
  LF.load322 = load i32 from ptr @LF
  call void putch(i32 %LF.load322)
  ret i32 0
}

external float getfloat()

external void putfloat(float )

external void putch(i32 )

void inorder(i32 root) {
entry253:
  256 = sub i32 0, i32 1
  257 = icmp ne i32 %root, i32 %256
  br i1 %257, bb %then258, bb %if.exit259
then258:
  261 = mul i32 %root, i32 4
  262 = ptradd ptr @left_child, i32 %261
  262.load = load i32 from ptr %262
  call void inorder(i32 %262.load)
  266 = mul i32 %root, i32 4
  267 = ptradd ptr @value, i32 %266
  267.load = load i32 from ptr %267
  call void putint(i32 %267.load)
  space.load = load i32 from ptr @space
  call void putch(i32 %space.load)
  273 = mul i32 %root, i32 4
  274 = ptradd ptr @right_child, i32 %273
  274.load = load i32 from ptr %274
  call void inorder(i32 %274.load)
  br bb %if.exit259
if.exit259:
  ret 
}

external void _sysy_stoptime(i32 )

external void putarray(i32 , ptr )

external void _sysy_starttime(i32 )

external void putfarray(i32 , ptr )


