immutable global ptr EPSILON init with float 0.000001
immutable global ptr PI init with float 3.141593
global ptr height init with i32 0
global ptr width init with i32 0
global ptr image init with 1048576 x i32 zeros
immutable global ptr MAX_HEIGHT init with i32 1024
immutable global ptr TWO_PI init with float 6.283185
immutable global ptr MAX_WIDTH init with i32 1024
i32 rotate(i32 x, i32 y, float rad) {
entry158:
  164 = call float my_sin(float %rad)
  167 = call float my_cos(float %rad)
  width.load169 = load i32 from ptr @width
  170 = sdiv i32 %width.load169, i32 2
  height.load172 = load i32 from ptr @height
  173 = sdiv i32 %height.load172, i32 2
  177 = sub i32 %x, i32 %170
  181 = sub i32 %y, i32 %173
  185 = si2f i32 %177 to float
  186 = fmul float %185, float %167
  189 = si2f i32 %181 to float
  190 = fmul float %189, float %164
  191 = fsub float %186, float %190
  193 = si2f i32 %170 to float
  194 = fadd float %191, float %193
  195 = f2si float %194 to i32
  200 = fmul float %185, float %164
  204 = fmul float %189, float %167
  205 = fadd float %200, float %204
  207 = si2f i32 %173 to float
  208 = fadd float %205, float %207
  209 = f2si float %208 to i32
  211 = icmp slt i32 %195, i32 0
  br i1 %211, bb %select.then212, bb %select.else213
select.then212:
  br bb %select.exit214
select.else213:
  width.load217 = load i32 from ptr @width
  218 = icmp sge i32 %195, i32 %width.load217
  br bb %select.exit214
select.exit214:
  select215.phi = phi [bb %select.else213, i1 %218, bb %select.then212, i1 1]
  br i1 %select215.phi, bb %select.then221, bb %select.else222
select.then221:
  br bb %select.exit223
select.else222:
  226 = icmp slt i32 %209, i32 0
  br bb %select.exit223
select.exit223:
  select224.phi = phi [bb %select.else222, i1 %226, bb %select.then221, i1 1]
  br i1 %select224.phi, bb %select.then229, bb %select.else230
select.then229:
  br bb %select.exit231
select.else230:
  height.load234 = load i32 from ptr @height
  235 = icmp sge i32 %209, i32 %height.load234
  br bb %select.exit231
select.exit231:
  select232.phi = phi [bb %select.else230, i1 %235, bb %select.then229, i1 1]
  br i1 %select232.phi, bb %then238, bb %if.exit239
then238:
  ret i32 0
if.exit239:
  width.load241 = load i32 from ptr @width
  242 = mul i32 %209, i32 %width.load241
  244 = add i32 %242, i32 %195
  245 = mul i32 %244, i32 4
  246 = ptradd ptr @image, i32 %245
  246.load = load i32 from ptr %246
  ret i32 %246.load
}

float my_sin_impl(float x) {
entry23:
  26 = call float my_fabs(float %x)
  EPSILON.load = load float from ptr @EPSILON
  28 = fcmp ole float %26, float %EPSILON.load
  br i1 %28, bb %then29, bb %if.exit30
then29:
  ret float %x
if.exit30:
  33 = fdiv float %x, float 3.000000
  34 = call float my_sin_impl(float %33)
  35 = call float p(float %34)
  ret float %35
}

float p(float x) {
entry10:
  13 = si2f i32 3 to float
  14 = fmul float %13, float %x
  16 = si2f i32 4 to float
  17 = fmul float %16, float %x
  19 = fmul float %17, float %x
  21 = fmul float %19, float %x
  22 = fsub float %14, float %21
  ret float %22
}

float my_sin(float x) {
entry36:
  TWO_PI.load = load float from ptr @TWO_PI
  40 = fcmp ogt float %x, float %TWO_PI.load
  br i1 %40, bb %select.then, bb %select.else
select.then:
  br bb %select.exit
select.else:
  TWO_PI.load46 = load float from ptr @TWO_PI
  47 = fneg float %TWO_PI.load46
  48 = fcmp olt float %x, float %47
  br bb %select.exit
select.exit:
  select.phi = phi [bb %select.else, i1 %48, bb %select.then, i1 1]
  br i1 %select.phi, bb %then51, bb %if.exit52
then51:
  TWO_PI.load55 = load float from ptr @TWO_PI
  56 = fdiv float %x, float %TWO_PI.load55
  57 = f2si float %56 to i32
  TWO_PI.load60 = load float from ptr @TWO_PI
  61 = si2f i32 %57 to float
  62 = fmul float %61, float %TWO_PI.load60
  63 = fsub float %x, float %62
  br bb %if.exit52
if.exit52:
  x.stack37.phi304 = phi [bb %select.exit, float %x, bb %then51, float %63]
  PI.load = load float from ptr @PI
  66 = fcmp ogt float %x.stack37.phi304, float %PI.load
  br i1 %66, bb %then67, bb %if.exit68
then67:
  TWO_PI.load70 = load float from ptr @TWO_PI
  71 = fsub float %x.stack37.phi304, float %TWO_PI.load70
  br bb %if.exit68
if.exit68:
  x.stack37.phi303 = phi [bb %if.exit52, float %x.stack37.phi304, bb %then67, float %71]
  PI.load73 = load float from ptr @PI
  74 = fneg float %PI.load73
  75 = fcmp olt float %x.stack37.phi303, float %74
  br i1 %75, bb %then76, bb %if.exit77
then76:
  TWO_PI.load79 = load float from ptr @TWO_PI
  80 = fadd float %x.stack37.phi303, float %TWO_PI.load79
  br bb %if.exit77
if.exit77:
  x.stack37.phi = phi [bb %if.exit68, float %x.stack37.phi303, bb %then76, float %80]
  82 = call float my_sin_impl(float %x.stack37.phi)
  ret float %82
}

external i32 getint()

external i32 getch()

external void putint(i32 )

external i32 getarray(ptr )

float my_cos(float x) {
entry83:
  PI.load86 = load float from ptr @PI
  87 = si2f i32 2 to float
  88 = fdiv float %PI.load86, float %87
  89 = fadd float %x, float %88
  90 = call float my_sin(float %89)
  ret float %90
}

external i32 getfarray(ptr )

i32 main() {
entry288:
  290 = call float getfloat()
  291 = call i32 getch()
  292 = call i32 read_image()
  293 = icmp slt i32 %292, i32 0
  br i1 %293, bb %then294, bb %if.exit295
then294:
  ret i32 -1
if.exit295:
  call void write_pgm(float %290)
  ret i32 0
}

i32 read_image() {
entry91:
  92 = call i32 getch()
  93 = icmp ne i32 %92, i32 80
  br i1 %93, bb %select.then94, bb %select.else95
select.then94:
  br bb %select.exit96
select.else95:
  98 = call i32 getch()
  99 = icmp ne i32 %98, i32 50
  br bb %select.exit96
select.exit96:
  select97.phi = phi [bb %select.else95, i1 %99, bb %select.then94, i1 1]
  br i1 %select97.phi, bb %then102, bb %if.exit103
then102:
  ret i32 -1
if.exit103:
  105 = call i32 getint()
  store i32 %105 to ptr @width
  106 = call i32 getint()
  store i32 %106 to ptr @height
  width.load = load i32 from ptr @width
  MAX_WIDTH.load = load i32 from ptr @MAX_WIDTH
  109 = icmp sgt i32 %width.load, i32 %MAX_WIDTH.load
  br i1 %109, bb %select.then110, bb %select.else111
select.then110:
  br bb %select.exit112
select.else111:
  height.load = load i32 from ptr @height
  MAX_HEIGHT.load = load i32 from ptr @MAX_HEIGHT
  116 = icmp sgt i32 %height.load, i32 %MAX_HEIGHT.load
  br bb %select.exit112
select.exit112:
  select113.phi = phi [bb %select.else111, i1 %116, bb %select.then110, i1 1]
  br i1 %select113.phi, bb %select.then119, bb %select.else120
select.then119:
  br bb %select.exit121
select.else120:
  123 = call i32 getint()
  124 = icmp ne i32 %123, i32 255
  br bb %select.exit121
select.exit121:
  select122.phi = phi [bb %select.else120, i1 %124, bb %select.then119, i1 1]
  br i1 %select122.phi, bb %then127, bb %if.exit128
then127:
  ret i32 -1
if.exit128:
  br bb %while.cond
while.cond:
  y.phi = phi [bb %if.exit128, i32 0, bb %while.exit141, i32 %157]
  height.load135 = load i32 from ptr @height
  136 = icmp slt i32 %y.phi, i32 %height.load135
  br i1 %136, bb %while.body, bb %while.exit
while.body:
  br bb %while.cond139
while.exit:
  ret i32 0
while.cond139:
  x.phi = phi [bb %while.body, i32 0, bb %while.body140, i32 %155]
  width.load143 = load i32 from ptr @width
  144 = icmp slt i32 %x.phi, i32 %width.load143
  br i1 %144, bb %while.body140, bb %while.exit141
while.body140:
  width.load147 = load i32 from ptr @width
  148 = mul i32 %y.phi, i32 %width.load147
  150 = add i32 %148, i32 %x.phi
  151 = mul i32 %150, i32 4
  152 = ptradd ptr @image, i32 %151
  153 = call i32 getint()
  store i32 %153 to ptr %152
  155 = add i32 %x.phi, i32 1
  br bb %while.cond139
while.exit141:
  157 = add i32 %y.phi, i32 1
  br bb %while.cond
}

external float getfloat()

external void putfloat(float )

void write_pgm(float rad) {
entry248:
  call void putch(i32 80)
  call void putch(i32 50)
  call void putch(i32 10)
  width.load253 = load i32 from ptr @width
  call void putint(i32 %width.load253)
  call void putch(i32 32)
  height.load256 = load i32 from ptr @height
  call void putint(i32 %height.load256)
  call void putch(i32 32)
  call void putint(i32 255)
  call void putch(i32 10)
  br bb %while.cond262
while.cond262:
  y261.phi = phi [bb %entry248, i32 0, bb %while.exit272, i32 %287]
  height.load266 = load i32 from ptr @height
  267 = icmp slt i32 %y261.phi, i32 %height.load266
  br i1 %267, bb %while.body263, bb %while.exit264
while.body263:
  br bb %while.cond270
while.exit264:
  ret 
while.cond270:
  x269.phi = phi [bb %while.body263, i32 0, bb %while.body271, i32 %284]
  width.load274 = load i32 from ptr @width
  275 = icmp slt i32 %x269.phi, i32 %width.load274
  br i1 %275, bb %while.body271, bb %while.exit272
while.body271:
  280 = call i32 rotate(i32 %x269.phi, i32 %y261.phi, float %rad)
  call void putint(i32 %280)
  call void putch(i32 32)
  284 = add i32 %x269.phi, i32 1
  br bb %while.cond270
while.exit272:
  call void putch(i32 10)
  287 = add i32 %y261.phi, i32 1
  br bb %while.cond262
}

external void putch(i32 )

external void _sysy_stoptime(i32 )

external void putarray(i32 , ptr )

external void _sysy_starttime(i32 )

external void putfarray(i32 , ptr )

float my_fabs(float x) {
entry:
  3 = si2f i32 0 to float
  4 = fcmp ogt float %x, float %3
  br i1 %4, bb %then, bb %if.exit
then:
  ret float %x
if.exit:
  9 = fneg float %x
  ret float %9
}


