global ptr cur_token init with i32 0
global ptr other init with i32 0
global ptr num init with i32 0
global ptr last_char init with i32 32
immutable global ptr TOKEN_OTHER init with i32 1
immutable global ptr TOKEN_NUM init with i32 0
i32 eval() {
entry186:
  %ops = stack 1024
  %oprs = stack 1024
  br bb %init.cond
init.cond:
  cnt_ptr.phi = phi [bb %entry186, i32 256, bb %init, i32 %cnt.dec]
  193 = icmp ne i32 %cnt_ptr.phi, i32 0
  br i1 %193, bb %init, bb %init.exit
init:
  cnt.dec = sub i32 %cnt_ptr.phi, i32 1
  offset = mul i32 %cnt.dec, i32 4
  arr.index198 = ptradd ptr %oprs, i32 %offset
  store i32 0 to ptr %arr.index198
  br bb %init.cond
init.exit:
  br bb %init.cond200
init.cond200:
  cnt_ptr203.phi = phi [bb %init.exit, i32 256, bb %init201, i32 %cnt.dec207]
  205 = icmp ne i32 %cnt_ptr203.phi, i32 0
  br i1 %205, bb %init201, bb %init.exit202
init201:
  cnt.dec207 = sub i32 %cnt_ptr203.phi, i32 1
  offset208 = mul i32 %cnt.dec207, i32 4
  arr.index210 = ptradd ptr %ops, i32 %offset208
  store i32 0 to ptr %arr.index210
  br bb %init.cond200
init.exit202:
  cur_token.load211 = load i32 from ptr @cur_token
  213 = icmp ne i32 %cur_token.load211, i32 0
  br i1 %213, bb %then214, bb %if.exit215
then214:
  216 = call i32 panic()
  ret i32 %216
if.exit215:
  num.load217 = load i32 from ptr @num
  call void stack_push(ptr %oprs, i32 %num.load217)
  219 = call i32 next_token()
  br bb %while.cond220
while.cond220:
  rhs.phi322 = phi [bb %if.exit215, i32 ub, bb %if.exit271, i32 %rhs.phi]
  lhs.phi318 = phi [bb %if.exit215, i32 ub, bb %if.exit271, i32 %lhs.phi]
  cur_op.phi315 = phi [bb %if.exit215, i32 ub, bb %if.exit271, i32 %cur_op.phi]
  cur_token.load223 = load i32 from ptr @cur_token
  225 = icmp eq i32 %cur_token.load223, i32 1
  br i1 %225, bb %while.body221, bb %while.exit222
while.body221:
  other.load = load i32 from ptr @other
  230 = call i32 get_op_prec(i32 %other.load)
  231 = icmp ne i32 %230, i32 0
  232 =  i1 %231, i1 1
  233 = zext i1 %232 to i32
  234 = icmp ne i32 %233, i32 0
  br i1 %234, bb %then235, bb %if.exit236
while.exit222:
  276 = call i32 next_token()
  br bb %while.cond277
then235:
  br bb %while.exit222
if.exit236:
  237 = call i32 next_token()
  br bb %while.cond238
while.cond238:
  rhs.phi = phi [bb %if.exit236, i32 %rhs.phi322, bb %while.body239, i32 %257]
  lhs.phi = phi [bb %if.exit236, i32 %lhs.phi318, bb %while.body239, i32 %259]
  cur_op.phi = phi [bb %if.exit236, i32 %cur_op.phi315, bb %while.body239, i32 %255]
  241 = call i32 stack_size(ptr %ops)
  242 = icmp ne i32 %241, i32 0
  br i1 %242, bb %select.then243, bb %select.else244
while.body239:
  255 = call i32 stack_pop(ptr %ops)
  257 = call i32 stack_pop(ptr %oprs)
  259 = call i32 stack_pop(ptr %oprs)
  263 = call i32 eval_op(i32 %255, i32 %259, i32 %257)
  call void stack_push(ptr %oprs, i32 %263)
  br bb %while.cond238
while.exit240:
  call void stack_push(ptr %ops, i32 %other.load)
  cur_token.load267 = load i32 from ptr @cur_token
  269 = icmp ne i32 %cur_token.load267, i32 0
  br i1 %269, bb %then270, bb %if.exit271
select.then243:
  247 = call i32 stack_peek(ptr %ops)
  248 = call i32 get_op_prec(i32 %247)
  250 = call i32 get_op_prec(i32 %other.load)
  251 = icmp sge i32 %248, i32 %250
  br bb %select.exit245
select.else244:
  br bb %select.exit245
select.exit245:
  select246.phi = phi [bb %select.else244, i1 0, bb %select.then243, i1 %251]
  br i1 %select246.phi, bb %while.body239, bb %while.exit240
then270:
  272 = call i32 panic()
  ret i32 %272
if.exit271:
  num.load273 = load i32 from ptr @num
  call void stack_push(ptr %oprs, i32 %num.load273)
  275 = call i32 next_token()
  br bb %while.cond220
while.cond277:
  280 = call i32 stack_size(ptr %ops)
  281 = icmp ne i32 %280, i32 0
  br i1 %281, bb %while.body278, bb %while.exit279
while.body278:
  283 = call i32 stack_pop(ptr %ops)
  285 = call i32 stack_pop(ptr %oprs)
  287 = call i32 stack_pop(ptr %oprs)
  291 = call i32 eval_op(i32 %283, i32 %287, i32 %285)
  call void stack_push(ptr %oprs, i32 %291)
  br bb %while.cond277
while.exit279:
  293 = call i32 stack_peek(ptr %oprs)
  ret i32 %293
}

i32 eval_op(i32 op, i32 lhs, i32 rhs) {
entry147:
  152 = icmp eq i32 %op, i32 43
  br i1 %152, bb %then153, bb %if.exit154
then153:
  157 = add i32 %lhs, i32 %rhs
  ret i32 %157
if.exit154:
  159 = icmp eq i32 %op, i32 45
  br i1 %159, bb %then160, bb %if.exit161
then160:
  164 = sub i32 %lhs, i32 %rhs
  ret i32 %164
if.exit161:
  166 = icmp eq i32 %op, i32 42
  br i1 %166, bb %then167, bb %if.exit168
then167:
  171 = mul i32 %lhs, i32 %rhs
  ret i32 %171
if.exit168:
  173 = icmp eq i32 %op, i32 47
  br i1 %173, bb %then174, bb %if.exit175
then174:
  178 = sdiv i32 %lhs, i32 %rhs
  ret i32 %178
if.exit175:
  180 = icmp eq i32 %op, i32 37
  br i1 %180, bb %then181, bb %if.exit182
then181:
  185 = srem i32 %lhs, i32 %rhs
  ret i32 %185
if.exit182:
  ret i32 0
}

i32 stack_size(ptr s) {
entry143:
  145 = ptradd ptr %s, i32 0
  145.load = load i32 from ptr %145
  ret i32 %145.load
}

i32 stack_peek(ptr s) {
entry136:
  138 = ptradd ptr %s, i32 0
  138.load = load i32 from ptr %138
  140 = mul i32 %138.load, i32 4
  141 = ptradd ptr %s, i32 %140
  141.load = load i32 from ptr %141
  ret i32 %141.load
}

i32 stack_pop(ptr s) {
entry121:
  124 = ptradd ptr %s, i32 0
  124.load = load i32 from ptr %124
  126 = mul i32 %124.load, i32 4
  127 = ptradd ptr %s, i32 %126
  127.load = load i32 from ptr %127
  132.load = load i32 from ptr %124
  134 = sub i32 %132.load, i32 1
  store i32 %134 to ptr %124
  ret i32 %127.load
}

i32 get_op_prec(i32 op) {
entry73:
  76 = icmp eq i32 %op, i32 43
  br i1 %76, bb %select.then77, bb %select.else78
select.then77:
  br bb %select.exit79
select.else78:
  82 = icmp eq i32 %op, i32 45
  br bb %select.exit79
select.exit79:
  select80.phi = phi [bb %select.else78, i1 %82, bb %select.then77, i1 1]
  br i1 %select80.phi, bb %then85, bb %if.exit86
then85:
  ret i32 10
if.exit86:
  88 = icmp eq i32 %op, i32 42
  br i1 %88, bb %select.then89, bb %select.else90
select.then89:
  br bb %select.exit91
select.else90:
  94 = icmp eq i32 %op, i32 47
  br bb %select.exit91
select.exit91:
  select92.phi = phi [bb %select.else90, i1 %94, bb %select.then89, i1 1]
  br i1 %select92.phi, bb %select.then97, bb %select.else98
select.then97:
  br bb %select.exit99
select.else98:
  102 = icmp eq i32 %op, i32 37
  br bb %select.exit99
select.exit99:
  select100.phi = phi [bb %select.else98, i1 %102, bb %select.then97, i1 1]
  br i1 %select100.phi, bb %then105, bb %if.exit106
then105:
  ret i32 20
if.exit106:
  ret i32 0
}

void stack_push(ptr s, i32 v) {
entry107:
  110 = ptradd ptr %s, i32 0
  112.load = load i32 from ptr %110
  114 = add i32 %112.load, i32 1
  store i32 %114 to ptr %110
  116.load = load i32 from ptr %110
  118 = mul i32 %116.load, i32 4
  119 = ptradd ptr %s, i32 %118
  store i32 %v to ptr %119
  ret 
}

i32 is_num(i32 c) {
entry18:
  21 = icmp sge i32 %c, i32 48
  br i1 %21, bb %select.then22, bb %select.else23
select.then22:
  27 = icmp sle i32 %c, i32 57
  br bb %select.exit24
select.else23:
  br bb %select.exit24
select.exit24:
  select25.phi = phi [bb %select.else23, i1 0, bb %select.then22, i1 %27]
  br i1 %select25.phi, bb %then29, bb %else31
then29:
  ret i32 1
else31:
  ret i32 0
}

i32 is_space(i32 c) {
entry3:
  6 = icmp eq i32 %c, i32 32
  br i1 %6, bb %select.then, bb %select.else
select.then:
  br bb %select.exit
select.else:
  12 = icmp eq i32 %c, i32 10
  br bb %select.exit
select.exit:
  select.phi = phi [bb %select.else, i1 %12, bb %select.then, i1 1]
  br i1 %select.phi, bb %then, bb %else
then:
  ret i32 1
else:
  ret i32 0
}

external i32 getint()

external i32 getch()

external void putint(i32 )

external i32 getarray(ptr )

external i32 getfarray(ptr )

i32 main() {
entry294:
  296 = call i32 getint()
  297 = call i32 getch()
  298 = call i32 next_token()
  br bb %while.cond299
while.cond299:
  count.phi = phi [bb %entry294, i32 %296, bb %while.body300, i32 %308]
  303 = icmp ne i32 %count.phi, i32 0
  br i1 %303, bb %while.body300, bb %while.exit301
while.body300:
  304 = call i32 eval()
  call void putint(i32 %304)
  call void putch(i32 10)
  308 = sub i32 %count.phi, i32 1
  br bb %while.cond299
while.exit301:
  ret i32 0
}

i32 panic() {
entry64:
  call void putch(i32 112)
  call void putch(i32 97)
  call void putch(i32 110)
  call void putch(i32 105)
  call void putch(i32 99)
  call void putch(i32 33)
  call void putch(i32 10)
  ret i32 -1
}

external float getfloat()

external void putfloat(float )

i32 next_token() {
entry32:
  br bb %while.cond
while.cond:
  last_char.load36 = load i32 from ptr @last_char
  37 = call i32 is_space(i32 %last_char.load36)
  38 = icmp ne i32 %37, i32 0
  br i1 %38, bb %while.body, bb %while.exit
while.body:
  39 = call i32 next_char()
  br bb %while.cond
while.exit:
  last_char.load40 = load i32 from ptr @last_char
  41 = call i32 is_num(i32 %last_char.load40)
  42 = icmp ne i32 %41, i32 0
  br i1 %42, bb %then43, bb %else45
then43:
  last_char.load46 = load i32 from ptr @last_char
  47 = sub i32 %last_char.load46, i32 48
  store i32 %47 to ptr @num
  br bb %while.cond48
if.exit44:
  cur_token.load = load i32 from ptr @cur_token
  ret i32 %cur_token.load
else45:
  last_char.load60 = load i32 from ptr @last_char
  store i32 %last_char.load60 to ptr @other
  61 = call i32 next_char()
  store i32 1 to ptr @cur_token
  br bb %if.exit44
while.cond48:
  51 = call i32 next_char()
  52 = call i32 is_num(i32 %51)
  53 = icmp ne i32 %52, i32 0
  br i1 %53, bb %while.body49, bb %while.exit50
while.body49:
  num.load = load i32 from ptr @num
  55 = mul i32 %num.load, i32 10
  last_char.load56 = load i32 from ptr @last_char
  57 = add i32 %55, i32 %last_char.load56
  58 = sub i32 %57, i32 48
  store i32 %58 to ptr @num
  br bb %while.cond48
while.exit50:
  store i32 0 to ptr @cur_token
  br bb %if.exit44
}

external void putch(i32 )

external void _sysy_stoptime(i32 )

external void _sysy_starttime(i32 )

external void putfarray(i32 , ptr )

external void putarray(i32 , ptr )

i32 next_char() {
entry:
  1 = call i32 getch()
  store i32 %1 to ptr @last_char
  ret i32 %1
}


