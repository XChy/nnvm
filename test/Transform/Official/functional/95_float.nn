immutable global ptr FIVE init with i32 5
immutable global ptr THREE init with i32 3
immutable global ptr RADIUS init with float 5.500000
immutable global ptr PI init with float 3.141593
immutable global ptr EPS init with float 0.000001
immutable global ptr EVAL3 init with float 34.557522
immutable global ptr PI_HEX init with float 3.141593
immutable global ptr HEX2 init with float 0.078125
immutable global ptr EVAL2 init with float 34.557522
immutable global ptr MAX init with i32 1000000000
immutable global ptr EVAL1 init with float 95.033188
immutable global ptr CONV1 init with float 233.000000
immutable global ptr FACT init with float -33000.000000
immutable global ptr CONV2 init with float 4095.000000
immutable global ptr TWO init with i32 2
void assert_not(i32 cond) {
entry68:
  71 = icmp ne i32 %cond, i32 0
  br i1 %71, bb %then72, bb %else74
then72:
  call void error()
  br bb %if.exit73
if.exit73:
  ret 
else74:
  call void ok()
  br bb %if.exit73
}

void ok() {
entry52:
  call void putch(i32 111)
  call void putch(i32 107)
  call void putch(i32 10)
  ret 
}

void error() {
entry45:
  call void putch(i32 101)
  call void putch(i32 114)
  call void putch(i32 114)
  call void putch(i32 111)
  call void putch(i32 114)
  call void putch(i32 10)
  ret 
}

float circle_area(i32 radius) {
entry10:
  PI.load = load float from ptr @PI
  14 = si2f i32 %radius to float
  15 = fmul float %PI.load, float %14
  18 = fmul float %15, float %14
  21 = mul i32 %radius, i32 %radius
  PI.load22 = load float from ptr @PI
  23 = si2f i32 %21 to float
  24 = fmul float %23, float %PI.load22
  25 = fadd float %18, float %24
  26 = si2f i32 2 to float
  27 = fdiv float %25, float %26
  ret float %27
}

external i32 getint()

external i32 getch()

i32 float_eq(float a, float b) {
entry28:
  33 = fsub float %a, float %b
  34 = call float float_abs(float %33)
  EPS.load = load float from ptr @EPS
  36 = fcmp olt float %34, float %EPS.load
  br i1 %36, bb %then37, bb %else
then37:
  40 = si2f i32 1 to float
  41 = fmul float %40, float 2.000000
  42 = si2f i32 2 to float
  43 = fdiv float %41, float %42
  44 = f2si float %43 to i32
  ret i32 %44
else:
  ret i32 0
}

external void putint(i32 )

external i32 getarray(ptr )

external i32 getfarray(ptr )

i32 main() {
entry77:
  %arr = stack 40
  HEX2.load = load float from ptr @HEX2
  FACT.load = load float from ptr @FACT
  80 = call i32 float_eq(float %HEX2.load, float %FACT.load)
  call void assert_not(i32 %80)
  EVAL1.load = load float from ptr @EVAL1
  EVAL2.load = load float from ptr @EVAL2
  84 = call i32 float_eq(float %EVAL1.load, float %EVAL2.load)
  call void assert_not(i32 %84)
  EVAL2.load86 = load float from ptr @EVAL2
  EVAL3.load = load float from ptr @EVAL3
  88 = call i32 float_eq(float %EVAL2.load86, float %EVAL3.load)
  call void assert(i32 %88)
  RADIUS.load = load float from ptr @RADIUS
  91 = f2si float %RADIUS.load to i32
  92 = call float circle_area(i32 %91)
  FIVE.load = load i32 from ptr @FIVE
  94 = call float circle_area(i32 %FIVE.load)
  95 = call i32 float_eq(float %92, float %94)
  call void assert(i32 %95)
  CONV1.load = load float from ptr @CONV1
  CONV2.load = load float from ptr @CONV2
  99 = call i32 float_eq(float %CONV1.load, float %CONV2.load)
  call void assert_not(i32 %99)
  101 = fcmp one float 1.500000, float 0.000000
  br i1 %101, bb %then102, bb %if.exit103
then102:
  call void ok()
  br bb %if.exit103
if.exit103:
  105 = fcmp one float 3.300000, float 0.000000
  106 =  i1 %105, i1 1
  107 = zext i1 %106 to i32
  108 = icmp ne i32 %107, i32 0
  109 =  i1 %108, i1 1
  110 = zext i1 %109 to i32
  111 = icmp ne i32 %110, i32 0
  br i1 %111, bb %then112, bb %if.exit113
then112:
  call void ok()
  br bb %if.exit113
if.exit113:
  115 = fcmp one float 0.000000, float 0.000000
  br i1 %115, bb %select.then, bb %select.else
select.then:
  br bb %select.exit
select.else:
  br bb %select.exit
select.exit:
  select.phi = phi [bb %select.else, i1 0, bb %select.then, i1 1]
  br i1 %select.phi, bb %then122, bb %if.exit123
then122:
  call void error()
  br bb %if.exit123
if.exit123:
  130 = fcmp one float 0.300000, float 0.000000
  br bb %select.exit128
select.exit128:
  select129.phi = phi [bb %if.exit123, i1 %130]
  br i1 %select129.phi, bb %then133, bb %if.exit134
then133:
  call void ok()
  br bb %if.exit134
if.exit134:
  139 = si2f i32 2 to float
  arr.index = ptradd ptr %arr, i32 0
  store float 1.000000 to ptr %arr.index
  arr.index141 = ptradd ptr %arr, i32 4
  store float %139 to ptr %arr.index141
  arr.index142 = ptradd ptr %arr, i32 8
  store float 0.000000 to ptr %arr.index142
  arr.index143 = ptradd ptr %arr, i32 12
  store float 0.000000 to ptr %arr.index143
  arr.index144 = ptradd ptr %arr, i32 16
  store float 0.000000 to ptr %arr.index144
  arr.index145 = ptradd ptr %arr, i32 20
  store float 0.000000 to ptr %arr.index145
  arr.index146 = ptradd ptr %arr, i32 24
  store float 0.000000 to ptr %arr.index146
  arr.index147 = ptradd ptr %arr, i32 28
  store float 0.000000 to ptr %arr.index147
  arr.index148 = ptradd ptr %arr, i32 32
  store float 0.000000 to ptr %arr.index148
  arr.index149 = ptradd ptr %arr, i32 36
  store float 0.000000 to ptr %arr.index149
  151 = call i32 getfarray(ptr %arr)
  br bb %while.cond
while.cond:
  p.phi = phi [bb %if.exit134, i32 0, bb %while.body, i32 %194]
  i.phi = phi [bb %if.exit134, i32 1, bb %while.body, i32 %192]
  MAX.load = load i32 from ptr @MAX
  157 = icmp slt i32 %i.phi, i32 %MAX.load
  br i1 %157, bb %while.body, bb %while.exit
while.body:
  160 = call float getfloat()
  PI.load162 = load float from ptr @PI
  164 = fmul float %PI.load162, float %160
  166 = fmul float %164, float %160
  169 = f2si float %160 to i32
  170 = call float circle_area(i32 %169)
  172 = mul i32 %p.phi, i32 4
  173 = ptradd ptr %arr, i32 %172
  176.load = load float from ptr %173
  179 = fadd float %176.load, float %160
  store float %179 to ptr %173
  call void putfloat(float %166)
  call void putch(i32 32)
  184 = f2si float %170 to i32
  call void putint(i32 %184)
  call void putch(i32 10)
  188 = fneg float 10.000000
  189 = fneg float %188
  190 = si2f i32 %i.phi to float
  191 = fmul float %190, float %189
  192 = f2si float %191 to i32
  194 = add i32 %p.phi, i32 1
  br bb %while.cond
while.exit:
  call void putfarray(i32 %151, ptr %arr)
  ret i32 0
}

external float getfloat()

external void putfloat(float )

external void putch(i32 )

external void _sysy_stoptime(i32 )

external void putarray(i32 , ptr )

void assert(i32 cond) {
entry56:
  59 = icmp ne i32 %cond, i32 0
  60 =  i1 %59, i1 1
  61 = zext i1 %60 to i32
  62 = icmp ne i32 %61, i32 0
  br i1 %62, bb %then63, bb %else65
then63:
  call void error()
  br bb %if.exit64
if.exit64:
  ret 
else65:
  call void ok()
  br bb %if.exit64
}

external void _sysy_starttime(i32 )

external void putfarray(i32 , ptr )

float float_abs(float x) {
entry:
  3 = si2f i32 0 to float
  4 = fcmp olt float %x, float %3
  br i1 %4, bb %then, bb %if.exit
then:
  8 = fneg float %x
  ret float %8
if.exit:
  ret float %x
}


